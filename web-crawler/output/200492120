电脑/网络 编程语言 C/C++ 
采用c语言实现首次适应算法完成主存空间的分配和回收 急
none
flag=str;%6;<br />    float length.length=free_table[i];<br />  scanf(&quot;<br />    used_table[k];).flag==0)<br />    {<br />     free_table[i];%6; &#47.length=0;*分配主存空间*/&#92;<br />     used_table[k].0f%9;<br />   break,1-分配主存;n选择功能项（0-退出;*a=2回收主存空间*&#47,used_table[i].flag=1;n&quot;<br />   if(used_table[k],used_table[i];输入要回收分区的作业名&quot;);<br />    else<br />     printf(&quot;<br />    break;i&lt;1&quot;0&quot;);k&lt;printf(&quot.address=10240;/i++)<br />  {<br />   uend_address=used_table[k].0f%9, used_table[i];), used_table[i].0f%6c&#92.length+used_table[k].length;<br />}/<br />    }<br />   }<br />   printf(&quot.flag=0;*已分分区长度;/<br />    free_table[i];<br />   break;<br />  case 3;&#92.address+free_table[i];选择功项(0~3) ;i++)<br />  used_table[i];n.address==fend_address)&#47,free_table[i];<br /> int k;/k&lt,i;*输出空闲区表和已分配表的内容*/n,i;*已分配表初始化;*while*/<br /><br /> for(i=0;输出空闲区表;n已回收;<br /> free_table[0];;<br /><br />void main( )<br />{<br /> int i;<br />     free_table[i];<br />   for(i=0;m;*假定系统允许的空闲区表最大为m;<br /> for(i=1;*a=0程序结束*/*a=1分配主存空间*&#47,2-回收主存;<br /> char J;*空闲区长度，假定模拟实验中m值为10*&#47.h&quot; /&#47：&#92;<br />     free_table[i],a.length;m;).address=0,输出已分配区表&#92;i&lt,&J);上邻<br />   {<br />    fflag=1;i&lt;/;<br />       printf(&quot;i&lt;/ 输出已分配区表.flag);*空闲区表登记栏标志: /<br />    for(i=0!&#92;<br />     break;i++)<br />   {<br />    if(free_table[i];k++)<br />  {<br />   if(used_table[k]，用&quot;<br />   for(i=0;=leg)<br />  {<br />   fflag=1;<br />     used_table[k];n&quot;*case*/i&lt;i++)<br />    printf(&quot;n起始地址 分区长度 标志&#92.flag;<br />     break，单位为字节*&#47.address.address.length-leg;表示空栏目*&#47!&#92;表示空栏目;<br />    printf(&quot.address=0;<br />     used_table[k];<br />     used_table[k];<br />     used_table[k];;<br />    free_table[i].length=free_table[i].flag==str)<br />  {<br />   uflag=1.address;<br /> void allocate(char str;<br /> else<br /> {<br />  for(i=0;n&quot; /m;for结束<br />  if(fflag==0)<br />  {<br />   i=0,float leg);&#47,used_table[i];n找不到该作业;n.length=leg.flag).flag=0;<br />}free_table[m];*已分配区表登记栏标志.address=used_table[k]:printf(&quot;<br /> free_table[0];<br />     used_table[k].flag=0;<br />     free_table[i].length;n&quot;<br />  }/<br />#define m 10 / /<br />   }<br />   else<br />   {<br />    if(free_table[i];<br />  case 1; <br />int uflag;<br /> int k;&#92;分配主存空间函数<br /> void reclaim(char str);&#47:&quot;).length=0.length;/ /m;<br />     break;<br /> int flag.address+ressize,float leg)<br />{<br /> uflag=0.address=used_table[k].length;;<br />  }<br />    <br /> }<br /> if(fflag==0)<br />  printf(&quot.flag=0;回收主存函数<br /> float xk;i++)<br /> {<br />  if(free_table[i];<br />   printf(&quot.length&gt; 按任意键;<br />#include&quot：&#92;<br />     used_table[k];<br />  for(k=0.flag=str.flag=0;<br />   getchar();没有该选项&#92.length;n&quot.address=free_table[i].length=used_table[k];n已回收.flag=1;*空闲区起始地址*/空闲表标志<br />float uend_address.address=free_table[i];<br />    break,free_table[i];);&#47.flag);<br /> for(k=0：*/*已分配区表*/<br />  }<br /> }<br /> if(uflag==0)<br />  printf(&quot;<br />  case 2,&a);); /n&quot;);i&lt;stdlib: exit(0),&xk).0f%6d&#92：*&#47!&#92;minisize)/&#47.address+used_table[k];下邻<br />    {<br />     fflag=1.address.flag=0.0f%9;<br />     free_table[i];<br />  printf(&quot.flag=1: /<br />    int flag;&#92;n&quot;<br /> float length;); /&#92.address;<br />   for(i=0;<br />     free_table[i];<br />     used_table[k].length=0!=0)<br />     printf(&quot.flag=1;<br />    used_table[k]: &quot;);;);0&quot;*假定系统允许的最大作业为n;for结束<br /> }<br />}<br />void reclaim(char str)<br />{<br /> uflag=0;printf(&quot，用&quot; /break，用&quot;<br />   fend_address=free_table[i];/分配表标志<br />int fflag.length=ressize;表示未分配*&#47.address;*a=3显示主存情况*/n&quot;fflag=0;k++)<br /> {<br />  if(used_table[k];);<br />  switch(a)<br />  {<br />  case 0.h&quot;<br />     printf(&quot;%*c%c&quot;<br />    }<br />   }<br />  }&#47,xk): /<br />     break;&#47.0f%6d&#92;<br />     free_table[i];/n起始地址 分区长度 标志&#92;m;fflag=0,used_table[i];<br />}used_table[n].length;&#47，假定模拟实验中n值为10*/float ressize;<br />   allocate(J.flag==0)<br />   {<br />    if(ressize&lt;n&quot.length+used_table[k];break;&#47.length!&#92;i++)<br /><br />    if(used_table[i];/*回收主存空间*/<br />#define n 10 /没有满足条件的空闲区&#92，你可以参考参考<br />#include&quot.address==uend_address)&#47，单位为字节*/<br />     free_table[i];i++)<br />  free_table[i],3-显示主存）&#92;输入作业名J和作业所需长度xk;%6;n已回收;<br /> else<br /> {<br />  ressize=free_table[i];.length.address=0;<br />     used_table[k].flag==1 && free_table[i];reclaim(J).length=free_table[i].length=0;<br />   printf(&quot.length=102400;*空闲区表*/<br /> while(1)<br /> {<br />  printf(&quot;%*c%c%f&quot;n&quot; /<br />     used_table[k];<br />    }<br />    else<br />    {<br />     used_table[k];*已分分区起始地址*/stdio;n;n&quot;<br /> }/剩余块过小<br />    {<br />     used_table[k]，我这有一个;<br />void allocate(char str, free_table[i];<br />float fend_address;<br />#define minisize 100<br />struct{<br /> float address,&J;<br />    }<br />   }<br />  }/*主函数结束*/<br />   default;*空闲分区表初始化;<br />    used_table[k];n&quot;<br />   scanf(&quot;<br />   scanf(&quot;i&lt;<br /> free_table[0];%d&quot，比方说数据结构方面有没有具体的要求;<br />     free_table[i];/n&quot;<br /><br />struct{<br /> float address
6
none
http://zhidao.baidu.com/question/261084902.html?qbl=relate_question_0
http://zhidao.baidu.com/question/505200804.html?qbl=relate_question_1
http://zhidao.baidu.com/question/253857616.html?qbl=relate_question_2
http://zhidao.baidu.com/question/245098959.html?qbl=relate_question_3
http://zhidao.baidu.com/question/275794472.html?qbl=relate_question_4
