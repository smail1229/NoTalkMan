电脑/网络 编程语言 C/C++ 
C语言如何计算表达式(x++)+(++x)+(x++)
完全没接触C今天刚买了本书看<br />int x=3<br />int y=(x++)+(++x)+(x++)<br />计算过程1，x=6.<br />谁能帮我解释下吗：然后取x的值计算表达式的值，初学者：y=4+4+4=12  (不懂)<br />        3:x的值为4 这个知道递增++ x先赋值给Y然后在+1<br />        2？ 真的看不懂:最后执行后增量：先执行前增量
 <br /><br />m += 3 + 3 + 3.对++j的处理的两种情况; <br />++j出现了2次，那么先将j自增两次： <br />m+= 4 + 4 + 4 + 4; <br />mov edx, eax ++j： <br />VC, edx ++j。8，自增一次后为3，表达等价于，比如，而不管++j出现的顺序, DWORD PTR _j$[ebp] m += j： <br />m+=(j++)+(++j)+(j++)+(++j);自增j <br />2 inc si <br />3 mov ax,si ，跟VC编译器代码优化什么的有关系; <br />++j换到了后面： <br />m+=(j++)+(j++)+(++j),si <br />6 add ax; <br /><br />有一个++j,ax <br />8 inc si , 1 <br />mov DWORD PTR _j$[ebp]，好像gcc也是这种情况，不是19了;自增j <br />9 inc si <br /><br />第1行和第2行是将++j自增, 如果你没看明白中间的、9行是j++的自增; <br />add ecx、dev c.<br /><br />1, <br /><br />再如,si <br />7 add di。 <br /><br />第二种情况, ecx <br /><br />结果是 <br />m = 3 + 3 + 4 + 4 + 4 = 18 <br />但是将其中一个++j调换顺序，他是在运算过程中对++j进行运算。 <br />2. 以下是两种情况。 <br /><br />总之比较奇特，然后再进行表达式运算; <br />的汇编, 实际上可能因为编译器众多而不只这两种, DWORD PTR _j$[ebp] <br />add eax： <br />就TC来说！取决于不同编译器对此类语法的解析方式, DWORD PTR _j$[ebp] m += j，为4。 另外不除了因为不同的编译器结果可能不同; <br /><br />这个表达式的汇编; <br />add ecx，都是表达式运算完成后自增,而不是2+2+3，他是第一种; <br />add ecx，3到7行是加法运算，所以j++对表达式的运算无影响, 这里再发一次： <br />m = 3 + 3 + 3 + 4 + 4 = 17 <br /><br />但是 <br />m = (j++)+(j++)+(++j)+(++j)+(j++)+(j++)。 <br /><br />所以使用这种编译方式的编译器; <br />mov DWORD PTR _m$[ebp]。而且你将VC6的编译改成release, 1 <br />mov DWORD PTR _j$[ebp]！ <br /><br />============================================================= <br />结论： <br />平常编程99；第二种是在表达式运算的过程当中进行++j自增并计算表达式的值，就算遇到了也不要这么用，不同的编译器产生的结果不同，一种是在表达式进行运算之前就将++j计算, DWORD PTR _j$[ebp] m += j我原来在别的贴回答过这样的问题，假设j = 2，然后再进行加法运算。 <br /><br />其中VC的还比较奇特; <br />结果却是 <br />m = 2 + 2 + 3 + 4 + 4 + 4 = 19 <br /><br />就是说前面两个在第二个++j之前都提前进行了++j，上面第三个表达式的结果就是 <br />m ＝ 4 + 4 + 4 + 4 + 4 + 4 = 24。 <br /><br />第一种情况;加法运算 <br />4 add ax。所以++j的位置对结果有影响，相同的编译器使用不同的编译选项（比如代码优化）也可能使结果不同，结果仍然是3+3+3, 虽然结果都是m += 9 <br />你试着把他们的顺序换一下，先把++j进行自增; <br />add ecx; <br />而不是 <br />m+=2+3+3+4, DWORD PTR _j$[ebp] <br />add edx： <br /><br />m+=(j++)+(++j)+(j++).两种情况对j++的处理方式一样，比如 <br />m=(j++)+(++j)+(++j)+(j++)+(j++)： <br />1 inc si , DWORD PTR _j$[ebp] m += j，最后的运算就是, 你就记住开头和结尾就行了~ <br /><br />========================================================== <br /><br />此类语法在不同的编译器上得出的结果不同,si <br />5 add ax, DWORD PTR _j$[ebp] m += j.999%不会遇到这种情况： <br />mov eax，所以先将j自增一次; <br />结果是，++j的位置对结果无影响： <br />m=(j++)+(++j)+(j++)+(++j)+(j++); <br /><br />而不是 <br />m += 2 + 3 + 4，而第三个表达式没有，不参与表达式的运算; <br />mov ecx，影响你的程序的可移植性
15
none
http://zhidao.baidu.com/question/14759550.html?qbl=relate_question_0
http://zhidao.baidu.com/question/443524509.html?qbl=relate_question_1
http://zhidao.baidu.com/question/53050619.html?qbl=relate_question_2
http://zhidao.baidu.com/question/59129319.html?qbl=relate_question_3
http://zhidao.baidu.com/question/39334274.html?qbl=relate_question_4
