电脑/网络 编程语言 C/C++ 
请问到哪里可以找C语言的库函数的代码,例如PRINTF函数的代码
none
fail
1
深入printf <br />&#47;***<br />*printf.c - print formatted<br />*<br />* Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.<br />*<br />*Purpose:<br />* defines printf() - print formatted data<br />*<br />*******************************************************************************&#47; <br /><br />#include <br />#include <br />#include <br />#include <br />#include <br />#include <br />#include <br /><br />&#47;***<br />*int printf(format, ...) - print formatted data<br />*<br />*Purpose:<br />* Prints formatted data on stdout using the format string to<br />* format data and getting as many arguments as called for<br />* Uses temporary buffering to improve efficiency.<br />* _output does the real work here<br />*<br />*Entry:<br />* char *format - format string to control data format&#47;number of arguments<br />* followed by list of arguments, number and type controlled by<br />* format string<br />*<br />*Exit:<br />* returns number of characters printed<br />*<br />*Exceptions:<br />*<br />*******************************************************************************&#47;<br /><br />int __cdecl printf (<br />const char *format,<br />...<br />)<br />&#47;*<br />* stdout &#39;&#39;PRINT&#39;&#39;, &#39;&#39;F&#39;&#39;ormatted<br />*&#47;<br />{<br />va_list arglist;<br />int buffing;<br />int retval;<br /><br />va_start(arglist, format);<br /><br />_ASSERTE(format != NULL);&#47;&#47;断言宏。如果输出格式字符串指针为空，则在DEBUG版下断言，报告错误。<br /><br />_lock_str2(1, stdout);<br /><br />buffing = _stbuf(stdout);&#47;&#47;stdout:指定输出到屏幕<br /><br />retval = _output(stdout,format,arglist);<br /><br />_ftbuf(buffing, stdout);<br /><br />_unlock_str2(1, stdout);<br /><br />return(retval);<br />}<br />以上为printf()的源代码<br />1、从含有可选参数函数中获得可选参数，以及操作这些参数<br />typedef char *va_list;<br />void va_start( va_list arg_ptr, prev_param ); <br />type va_arg( va_list arg_ptr, type );<br />void va_end( va_list arg_ptr );<br />假定函数含有一个必选参数和多个可选参数，必选参数声明为普通数据类型，且能通过参数名来获得该变量的值。可选参数通过宏va_start、va_arg和va_end（定义在stdarg.h或varargs.h中）来进行操作，即通过设置指向第一个可选参数指针、返回当前参数、在返回参数后重新设置指针来操作所有的可选参数。<br />va_start:为获取可变数目参数的函数的参数提供一种便捷手段。设置arg_ptr为指向传给函数参数列表中的第一个可选参数的指针，且该参数必须是va_list类型。prev_param是在参数列表中第一个可选参数前的必选参数。<br />va_arg：返回由arg_ptr所指向的参数的值，且自增指向下一个参数的地址。type为当前参数的类型，用来计算该参数的长度，确定下一个参数的起始位置。它可以在函数中应用多次，直到得到函数的所有参数为止，但必须在宏va_start后面调用。<br />va_end:在获取所有的参数后，设置指针arg_ptr为NULL。<br />下面举例说明：<br />#include <br />#include <br />int average( int first, ... );<br />void main( void )<br />{<br />&#47;* Call with 3 integers (-1 is used as terminator). *&#47;<br />printf( &quot;Average is: %d&#92;n&quot;, average( 2, 3, 4, -1 ) );<br /><br />&#47;* Call with 4 integers. *&#47;<br />printf( &quot;Average is: %d&#92;n&quot;, average( 5, 7, 9, 11, -1 ) );<br /><br />&#47;* Call with just -1 terminator. *&#47;<br />printf( &quot;Average is: %d&#92;n&quot;, average( -1 ) );<br />}<br /><br />int average( int first, ... )<br />{<br />int count = 0, sum = 0, i = first;<br />va_list marker;<br /><br />va_start( marker, first ); &#47;* Initialize variable arguments. *&#47;<br />while( i != -1 )<br />{<br />sum += i;<br />count++;<br />i = va_arg( marker, int);<br />}<br />va_end( marker ); &#47;* Reset variable arguments. *&#47;<br />return( sum ? (sum &#47; count) : 0 );<br />}<br />返回值为：<br />Average is: 3<br />Average is: 8<br />Average is: 0<br />综上所述，在printf()函数中，可以只输出一个字符串，也可按照一定的形式输出含有多个可选参数的字符串信息。因此，首先就要通过这些宏来获取所有的可选参数。在上面的源码可以看出printf()中，只使用了宏at_start,将可选参数的首地址赋给了arglist。<br />2、锁定字符串及输出字符串到屏幕<br />#define _lock_str2(i,s) _lock_file2(i,s)<br />void __cdecl _lock_file2(int, void *);<br />#define _unlock_str2(i,s) _unlock_file2(i,s)<br />void __cdecl _unlock_file2(int, void *);<br />int __cdecl _stbuf(FILE *);<br />void __cdecl _ftbuf(int, FILE *);<br />int __cdecl _output(FILE *, const char *, va_list);<br />在output函数中，读取格式字符串中的每一个字符，然后对其进行处理，处理方式根据每一个字符所代表的意义来进行，如：普通字符直接利用函数WRITE_CHAR(ch, &charsout);输出到控制台。<br />其中的主要部分是对转换说明符（d,c,s,f）的处理，现在将对其中的部分代码进行详细说明，这里只说明最基本的转换说明符，对这些须基本的转换说明符进行修饰的修饰符，程序中单独进行处理。下面是函数output()(output.c)部分源代码：<br />case ST_TYPE:<br />&#47;&#47;表示当前处理的字符的类型为转换说明符。<br />...<br />switch (ch) {<br />&#47;&#47;下面对参数的获取都是利用宏va_arg( va_list arg_ptr, type );来进行的。<br />case &#39;&#39;c&#39;&#39;: {<br />&#47;&#47;从参数表中获取单个字符，输出到缓冲字符串中，此时，type=int <br />buffer[0] = (char) get_int_arg(&argptr); &#47;* get char to print *&#47;<br />text = buffer;<br />textlen = 1; &#47;* print just a single character *&#47;<br />}<br />break;<br /><br />case &#39;&#39;s&#39;&#39;: {<br />&#47;&#47;从参数表中获取字符串，输出到缓冲字符串中，此时，type=char*<br />int i;<br />char *p; &#47;* temps *&#47;<br />text = get_ptr_arg(&argptr);<br />...<br />}<br />break;<br /><br />case &#39;&#39;w&#39;&#39;: {<br />&#47;&#47;对宽字符进行处理<br />...<br />} &#47;* case &#39;&#39;w&#39;&#39; *&#47;<br />break;<br />...<br />case &#39;&#39;e&#39;&#39;:<br />case &#39;&#39;f&#39;&#39;:<br />case &#39;&#39;g&#39;&#39;: {<br />&#47;&#47;对浮点数进行操作<br />...<br />#if !LONGDOUBLE_IS_DOUBLE<br />&#47;* do the conversion *&#47;<br />if (flags & FL_LONGDOUBLE) {<br />_cldcvt((LONGDOUBLE*)argptr, text, ch, precision, capexp);<br />va_arg(argptr, LONGDOUBLE);<br />&#47;&#47;对长双精度型进行处理，此时，type=long double<br />}<br />else<br />#endif &#47;* !LONGDOUBLE_IS_DOUBLE *&#47;<br />{<br /><br />&#47;&#47;对双精度型进行处理，此时，type=double<br />_cfltcvt((DOUBLE*)argptr, text, ch, precision, capexp);<br />va_arg(argptr, DOUBLE);<br />}<br />...<br />break;<br />&#47;&#47;对整型变量处理<br />case &#39;&#39;d&#39;&#39;:<br />case &#39;&#39;i&#39;&#39;:<br />...<br />goto COMMON_INT;<br /><br />case &#39;&#39;u&#39;&#39;:<br />radix = 10;<br />goto COMMON_INT;<br /><br />case &#39;&#39;p&#39;&#39;:<br />...<br />goto COMMON_INT;<br /><br />case &#39;&#39;o&#39;&#39;:<br />...<br /><br />注：对于浮点型double和long double，有相应的转换说明符（%f表示双精度型，%lf表示长双精度型），而float却没有。其中的原因是，在K&RC下，float值用于表达式或用作参数前，会自动转换成double类型。而ANSI C一般不会自动把float转换成double。有些程序已假定其中的float参数会被转换成double,为了保护大量这样的程序，所有printf()函数的float参数还是被自动转换成double型。因此，在K&RC或ANSI C下，都无需用特定的转换说明符来显示float型。<br />综上所述，转换说明符必须与待打印字符的类型。通常，用户有种选择。例如，如要打印一个int类型的值。则只可以使用%d,%x或%o。所有这些说明符都表示要打印一个int类型的值；它们只不过提供了一个数值的几种不同表示。类似一，可以用%f、%g和%e来表示double类型的值。但如果转换说明与类型不匹配，将会出现意想不到的结果。为什么呢？问题就在于C向函数传递信息的方式。<br />这个失败的根本细节与具体实现相关。它决定了系统中的参数以何方式传递。函数调用如下：<br />float n1;<br />double n2;<br />long n3;<br />long n4;<br />...<br />printf(&quot;%ld,%ld,%ld,%ld&quot;,n1,n2,n3,n4);<br />这个调用告诉计算机，要把变量n1,n2,n3和n4的值交给计算机，它把这些变量放进称作栈（stack）的内存区域中，来完成这一任务。计算机把这些值放进栈中，其根据是变量的类型而不是转换说明符，比如n1,把8个字节放入栈中（float被转换成double），类似地，为n2放了8字节，其后给n3和n4各放了4个字节。接着，控制的对象转移到printf()；此函数从栈中读数，不过在这一过程中，它是在转换说明符的指导下，读取数值的。说明符%ld指定printf()应读4个字节(va_arg( va_list arg_ptr, type )中type=long)，因此printf()读入栈中的4个字节，作为它的第一个值。但是这只是n1的前半部分，这个值被看成一个long整数。下一个说明符%ld读入4个字节，这正是n1的后半部分，这个值被看成第二个long整数。类似地，第三、第四次又读入n2的前后两部分。因此，尽管我们对n3和n4使用了正确的说明符，printf()仍然会产生错误。
http://zhidao.baidu.com/question/439668946.html?qbl=relate_question_0
http://zhidao.baidu.com/question/195289709.html?qbl=relate_question_1
http://zhidao.baidu.com/question/87054011.html?qbl=relate_question_2
http://zhidao.baidu.com/question/60921121.html?qbl=relate_question_3
http://zhidao.baidu.com/question/90331787.html?qbl=relate_question_4
