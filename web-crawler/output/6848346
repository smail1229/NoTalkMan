电脑/网络 编程语言 C/C++ 
求C语言常用和基本结构类型
如冒泡排序<br />选择排序<br />检索（查找）算法<br />无序数据序列的查找<br />有序数据序列的查找（二分法查找）<br />遍历算法<br />一维数组和二维数组的遍历<br />单向链表的遍历<br />文件的遍历<br />其它基本算法<br />以上算法最好带几个典型的例子不错的追加50分先在这谢谢大家帮忙找找
)：t = &quot;<br />    shellsort(L,1; L.r[n];<br />      printf(&quot.h&quot.r[j];<br />   if(L.r[i-d];<br />    for(j=0;<br />    while(low&lt; i&lt.key)   break;=m && j&lt,m.key.堆排序;<br />    printf(&quot,L,&quot.r[0].r[i]; i++)<br />  printf(&quot.r[k].key = temp,j,&L;&#92.key); L; L;=pivotkey)   --high.r[j],h);n1;快速排序结果.key).r[j];<br />    L,temp;%d&quot;n&quot;;*   折半插入  */<br /> }<br /> for(i=1;<br />}<br />void heapsort(sqlist &L){<br /> int i;     /n&lt.r[n].r[i].length,m+1: { printf(&quot: { radixsort(L);<br />     for(j=i-d.r[k];<br /> for(j=m;);++i)<br />       if(L;%d.r[i].基数排序;基数排序结果;<br /> for(i=1.length.直接插入排序,L; L.r[i].&#92;<br />#include&quot;*   快速排序  */2;n&quot.r[0].key.key): b = 0.r[high];: { printf(&quot;.key;%d.key&lt;<br />  else  T;<br />      qsort(L;L.r[i++];<br />      break.key);<br />}<br /><br />/归并排序结果.r[high],t.r[i];L;<br />    for(n=0.key.length); <br />      for(n=1.key &gt;n&quot.r[0],&m);关键字项<br />}redtype.key = temp;<br />      printf(&quot.r[low];n0.key &lt; ++i){<br />   k = L; i &lt;= n)  T;<br />      break; i&gt;<br />      printf(&quot,int m){<br /> int j;<br />      for(n=1;j &lt; n++)<br />      printf(&quot;<br />void selectsort(sqlist &L){<br />    int i; n &lt;<br />    for(i=1;).key = L:&quot;   s = j;<br />      break; S.key){<br /> L;输入的数中最多为几位; i &lt;<br /> while(b == 1){<br />  printf(&quot.r[0]:&quot;<br /> for(j=2*s;n&quot;<br /> }<br />}<br />void mergesort(sqlist &L){<br /> msort(L;*   希尔排序  */<br />     insertsort(L),k; }<br />  case 9;<br />void radixsort(sqlist &L){<br /> int i,int dl[];<br />    printf(&quot.length).key).&#92.key)<br />     k = j;<br />void insertsort(sqlist &L){<br />    int i; n &lt,high);/&#92.r[i].length+1;);<br />  heapajust(L.r[0] = L;.length,int high){<br />    int pivotloc;<br />     L;%d&quot.key;<br /> L; L;<br />    break;<br /> scanf(&quot; ++j)<br />   {<br />     if(L,L; n &lt:&quot;<br /> sqlist T2,pivotloc+1;=L;<br />  }<br /> }<br />}<br /><br />这是基本的几种算法;n&quot.key = f[p][q].key)<br />   T;<br />    }<br />}<br /><br />/ i++)<br />  printf(&quot,&quot; n++)<br />      printf(&quot;冒泡排序结果.希尔排序&#92; q&lt.key = S.key&lt.r[low] = L.key){<br /> L.r[j].key &lt;--j)<br />  L;<br /><br />typedef struct{<br /> redtype r[MAXSIZE+1].length+1;); n &lt;<br />      printf(&quot.length+1;   <br />      selectsort(L);%d;<br />      break,L.r[n]，其他的应该不难.key &lt;<br />    for(i=2.key);j&lt.key;<br />   }<br />    }<br />}<br /><br />&#47,int i,q; L;t;<br />      mergesort(L);<br />}<br /><br />&#47.length.key;<br /> if(l == h)  T1.&#92; n++)<br />      printf(&quot,high.r[0] = L, k=i; <br /> b = 1;);++i)<br />      if(L.key)   ++j;  i++,&quot;++k)<br />     shellinsert(L,sqlist &T;  }<br />  case 2;%d.r[k];;=L!= i){      <br />      temp = L;n6,i.r[1];<br />   }<br />  case 4;L.r[i];i&lt.key: { printf(&quot;<br />    return low; <br />     printf(&quot.r[i+1];n3;t,&L,dl[k]).冒泡排序&#92;<br /> L; }<br />  case 3; high){<br /> pivotloc = partition(L.r[n],1;L.r[i]; i &lt.r[n].r[k];%d;<br />    printf(&quot;<br />  L; i++)<br />  printf(&quot;<br />      bubble(L),int h){<br /> int m.r[i+1] = L;<br />      printf(&quot;n5;<br /> }<br />}<br /><br />&#47.r[i];<br /> int     length;n输入希尔排序的基数; p++)<br />  for(q=0.key = L; L.r[0] = L.key):&quot.length+1; j&gt.r[j++].r[s]; L.key.r[low],L.length+1.key).key&gt;<br />    if(low &lt;*   堆排序  */1,sqlist &T1,m-j)))%10.退出; L;malloc.r[i],low.r[k++];n7; L.key){<br />     L.length/<br /> for(n=1,L,int high){<br />    int pivotkey; p&lt;<br />      break.r[low];10.length; --i)<br />  heapajust(L.length).key = L;<br />  switch(a){<br />  case 1,&quot.折半插入排序;%d,&a);high && L,L;0.r[i-1]; f[p][q] ;high && L;<br />      printf(&quot;<br />   p = 0,i;<br /> L;<br />     break.key = S.key = L; high=i-1;%d;);=L.key; j*=2){<br />  if(j&lt;<br />}<br />void qsort(sqlist &L.r[i] = L;<br />}<br /><br />/k&lt.r[i].r[i].r[0];=m.r[i++]; i&lt;&#92; n++)<br />      printf(&quot;<br /> while(low &lt;<br /> qsort(L;*   基数排序  */&#92; L;<br /> for(i=L;);j&gt,int l:&quot.key = temp;<br />      break,low:&quot; j&lt:&quot,l;<br />    for(i=d+1;);<br /> while(j &lt;<br />    for(k=0;).&#92.key = S,j;j&gt.r[j+1] = L;  }<br />  case 0.length+1.key);&#92; }<br />  case 8.h&quot,j,L.r[s];<br /> int f[10][10],&t).key.r[j];Please input the length .r[0] = L;<br />     L,&quot;<br /> qsort(L;).key: { printf(&quot,m).length;;);L;--j)<br /> L;%d: { printf(&quot;%d&quot; n++)<br />     scanf(&quot;%d&quot;n8;;<br />      for(n=1;.r[i].key;%d&quot;=high+1;<br /> }<br /> while(i &lt;&#92;m && L; n &lt.r[i];<br /> for(j=i-2;) .r[j+1];<br /> L;<br />      for(n=1:&quot; p&lt; --j){<br />  for(p=0;<br /> printf(&quot;<br />   while(p .快速排序&#92;&#92; i++)<br />  printf(&quot.r[low]; q = 0;math.r[s]:&quot.key;/<br />  }<br />  i = 1.length.r[m];;;直接插入排序结果;<br />     break;<br />      printf(&quot;   break,j,i;<br />  scanf(&quot;; q++)<br />  f[p][q] = 0.length+1.&#92;<br /> }<br /> L;<br />void shellinsert(sqlist &L;);):&quot;); n &lt.r[high+1] = L;<br /> temp = L.&#92;<br />}<br /><br />/<br />   while(f[p][q] ;i&lt;n&quot.length,int m;<br />      L;<br />void heapajust(sqlist &L;<br /> for(j=m+1;<br />   f[p][q] = L;n&quot;;n2,&quot; L!= 0)  q++; ++k){<br />  if(S;<br /> for(i=L,i-1),L,dl;0 && L;L.r[j+d] = L: { printf(&quot;10.key;= m)  T.key/n&quot; i &lt;<br /> printf(&quot;<br />int partition(sqlist &L;顺序表类型<br /><br />&#47,L;n希尔排序结果;),int d){<br />    int i.r[l].key &lt,n;*   归并排序  */<br />      L.key,b.r[j + 1] = L;<br />   msort(S,j; L.r[0].r[0].r[k];<br />#include&quot;将数组每位都置0<br />  for(i=1; i&gt;<br />  L,m;; i&lt,int t){<br /> int k;= high){<br />   m = (low+high)/<br />void bubble(sqlist &L){<br />    int i;<br />}<br />void msort(sqlist S,j;n9; p++)<br />   for(q=0;折半插入排序结果.length; q++)<br />   { L;<br />  if(temp &gt; L;<br />    int a;<br />   else   low = m+1;  }<br />  case 5;请输入希尔排序的基数个数;<br />#define   MAXSIZE   20<br /><br />typedef struct{<br /> int key.r[j].r[0];<br />   low=1,int low; }<br />  case 6;<br />  for(p=0;n4.r[i].归并排序&#92;<br /> int dl[10];&#92.key &lt; ++i){<br />      k = i,1; L.r[i].r[i+1].length+1;);++i){<br />   L: {<br />    printf(&quot;简单选择排序结果.r[low].r[j+d] = L.r[1],&quot;<br />}<br /><br />&#47,t);&#92;high){<br /> while(low&lt.length-j;(int(pow(10;<br />   msort(S;&#92;);=pivotkey)   ++low;<br /> while(low&lt;<br />      for(n=1; n++)<br />      printf(&quot?&quot.length+1;<br />     binsertsort(L).key&lt;<br />void merge(sqlist S;<br /> L: { printf(&quot;stdio.key),int n){<br /> int j,&dl[n]);顺序表长度<br />}sqlist;n&quot!= 0.key &gt;<br /> scanf(&quot.r[j] ,int low; --i)<br /> {   temp = L,T1.r[n];).r[i];<br />   }<br />      if(k ;<br />    scanf(&quot;<br />      for(j = i+1;<br />    }<br /> for(i=1.r[j+1] = L,int s;         / <br />      heapsort(L);*   冒泡排序  */     / L;<br />void binsertsort(sqlist &L){<br />    int low.r[j];<br /> else{<br />   m = (l+h)/<br />    }<br />    L,&quot;<br />    pivotkey = L,h);  }<br />  case 7;++j)<br />    for(i=1.length),L,k;);;<br /> L.r[l];<br />   merge(T2,T2;/ L.key = S.r[i].r[j];i&lt;n请选择,k,&quot;&#92,p.r[j++].h&quot;*   直接插入   *&#47.r[i-1],pivotloc-1).r[i],l;<br />       }<br />}<br />void shellsort(sqlist &L;&#92;); <br />     printf(&quot;++i)<br />      if(L;<br />    for(i=2,temp;=n;&#47!= k)  p++.r[k++];),temp;                &#47,L.key)<br />           high = m-1.r[j];%d.r[high],i;L;%d&quot;<br />     L,L;n++)<br />    scanf(&quot.length+1:&quot; }<br /> }<br />}<br /><br />void main()<br />{   sqlist L,m; <br />      }<br />    for(j=i-1;*   简单选择排序  */0.r[i] = L.key;堆排序结果.key = S.key = L;2,T2;= L.r[0] = L,high).简单选择排序;i&lt;j=j-d)<br />     L;<br /> }<br /> for(i=1#include&quot;;2;=L:&quot
0
none
http://zhidao.baidu.com/question/218249325.html?qbl=relate_question_0
http://zhidao.baidu.com/question/382742066.html?qbl=relate_question_1
http://zhidao.baidu.com/question/40437899.html?qbl=relate_question_2
http://zhidao.baidu.com/question/285638810.html?qbl=relate_question_3
