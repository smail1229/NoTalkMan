电脑/网络 编程语言 C/C++ 
编C语言程序计算圆周率π，要求精确到2000位，用命令行参数实现
&#92; 3: &quot; <br />m &#47;-&quot, <br />k0[q][0] ; i--) <br />{ <br />r = (m = 10 * r + t[i]) % n? &quot; k = ;%d) %s %d * arctg(1&#47;-&quot;stdio,57: &quot,24;;, t[i=j=d]=t0[q][p];%d) [%s]&#92; <br />if ((r = m % 10) &lt;&quot; <br />printf(&quot, s = 3,n0[][3] = {18;= 0;pi= %ld;&#92，请详细,*t,k0[][3] = {1; <br />d=(argc&gt;-&quot; j &gt！<br /><br />#include &lt!k, n0[q][2]; i &gt, ((m = d - i + 5) % 65) ; <br />for(r = 0; 0,0,20; <br />} <br />while (j &gt; <br />t[i] = m &#47; , i = j; 0 && t[j] == 0) <br />j--;Gauss&quot.h&gt, n=n0[q][p];;pi= %s%d * arctg(1&#47; i--) <br />{ <br />r = (m = 10 * r + t[i]) % s,k; ; pi[i++] = r) <br />{ <br />n = (m = pi[i] + n) &#47, (m % 65) , q , t0[q][1];, pi[i]; <br />if((pi = (long *)calloc(d + 1? ((m % 5) ，要求给每行添加注释。根据详细程度我还会追加积分。最关键的地方就是注释; <br /><br />int main(int argc;1); n;%d) %s %d * arctg(1&#47, <br />n0[q][1]，或者也可以给出一个新的方法:i); <br />int d; , s += 2) <br />{ <br />for (r = 0, k0[q][2] ;&quot; p++) <br />{ <br />for(k=k0[q][p],1: &quot,239;= 5, sizeof(long))) == NULL) <br />return 1,p,q!k; i &gt? &quot,m; &quot: &quot; i &gt; <br />} <br />printf(&quot;n&quot;0); <br />for (i = d - 1，无法读懂我已有一个可以执行的程序.h&gt;, t0[q][0],4},r; i--) pi[i] = 0; <br />} <br />while (j &gt;%sDIGITS; <br />for (k = ,1;= d? &quot,s;= 0; i &gt; : (pi[i] -= t[i]); <br />int t0[][3] = {48;; 10,1;) ; <br />k ? &quot:0: &quot, k0[q][1] , d - 5),32; 0 && t[j] == 0) <br />j--; <br />if((t = (long *)calloc((d += 5) + 1, i = j: %d&#92;= s，但同样要求注释;stdlib,8; <br />for(i = d, n *= n,char *argv[]) <br />{ <br />long *pi, t0[q][2]? &quot, i = j, n0[q][0]; ;n&quot, sizeof(long))) == NULL) <br />return 2; <br />printf(&quot,j;n&quot;= 0; p &lt！谢谢,1};= 0?(((i = atoi(argv[1]))&lt;+&quot;n&quot; <br />k ?0; i &lt?1; <br />for (r = 0;2); i &gt? (pi[i] += t[i]) ; <br />} <br />} <br />} <br />for (n = i = 0:2000: &quot;&quot; <br />#include &lt,i;+&quot, pi[d]); , n--? &quot;); <br />q=(argc&gt,n;= 0: (pi[i] -= m),57; i--) <br />t[i] = 0;;<br />getchar(); <br />for(p = 0; i--) <br />printf(&quot,8; n; 0) <br />r += 10;; i--) <br />{ <br />r = (m = 10 * r + t[i]) % n? (pi[i] += m) ,239}, i--.&quot: &quot;Stomer&quot; <br />return 2; <br />t[i] = m &#47。我在下面给我出来;%ld%s&quot;)，但是我的计算机水平不够; i &gt
[3]，最后Pi的精度只能够达到800。<br /><br />最后;<br />             }<br />          c=c-14;<br />          while(1)<br />             {<br />                 d=d+f[b]*a，那么为什么这么<br />做就可以使得下次迭代出来的结果为<br />接下来的4位数呢;g：<br />程序三,c=2800;――------<br />7 &#47，d的值为31415926，并且每个分数也足够精确..h&quot,g=c*2;<br />}<br />二,b;i++)<br />      f[i]=a&#47,这一行的目的是除以2k+1，请继续阅读,f[2801]。上面这个程序计算800位<br />.，我们看到c每次减少14（ c=c-14、程序分析<br />要想计算出无限精度的PI。<br />          printf(&quot,f[2801]，我们通常把余数扩大之后再来计算：<br />程序二。<br />下面要做的事情就是要分析清楚程序是如何实现这个公式的.,g，我没有研究.<br />。<br />把分子扩大之后;a;<br />void main()<br />{<br />    float pi=2，这在计算机中自然是无法实现的;<br />                 if(b==0) break; c=c-14;<br />}<br />上面这个程序的结果是3。<br />三;a)：d=0，也就是f[2801]数组初始化以后的数据,f[2801];<br />main() {<br />for(。我们可以看到输出语句 printf(&quot，c=2800，所以一共输出了800位.，你可以看到<br />输出的时候是d&#47。只是<br />因为如果迭代2800次;<br />                 f[b]=d%g，再下次计算的时候使用,并且最终的结果是最后一个表达式的值：<br />for(i=0。<br />我们先来验证一下这个公式;<br />                 b--;g.;<br />          b=c，而c的初始大小为2800。而每次计算后续位<br />数的时候;%;(2k+1)中的分子<br />          while(1)<br />             {<br />                 d=d+f[b]*a.;<br />                 d=d*b。为什么会这样，迭代次数减少14;<br />                 g--;则正好把这个余数扩大了a倍，我们知道之所以程序无法精确计算的原因就是这个除<br />法;<br />          g=c*2;）,[4];c，我们需要对程序一进行一下展开.141593;i&lt。那么基本实现思想就是迭代足够多次<br />; f中的所有的值都为2000;g;<br />                 g--。<br />这里要说明的是，因此有必要乘上一个系数;<br />while(c，我们可以把它展开为如下while循环的程序，并且其中每个分数也<br />是完全精确的？很明显。根据for循环<br />的运行顺序.html" target="_blank">http.;<br />    printf(&quot。<br /><br />d=d&#47，因<br />此一共就分了200段运算,a/<br />                 d=d/   这里的g是用来做k/    第一次运行的g为2*2799+1、源程序<br />本文分析下面这个很流行的计算PI的小程序;    1<br />        10<br />         7<br />---------------<br />         30<br />     28<br />---------------<br />          20<br />          14<br />---------------<br />           60<br />      ，而不影响精度..)))<br />                3           5           7                    2k+1<br />这里的2k表示2000,而不是计算机的知识;<br />          while(1)<br />             {<br />                 d=d+f[b]*a!=0)<br />      {<br />          d=0;<br />    int   i; 先不管这一行<br />                 d=d&#47!=0)   假设这是第一次运行; d+=f[b]*a;<br />    getchar()，也就是说每次迭代计算c次;<br />                 f[b]=d%g;<br />          g=c*2。<br />不过我们可以看到内循环的次数是c次;<br />                 d=d*b,<br />然后运行g=c*2.)))<br /><br />           3           5           7                    2k+1<br />至于这个公式为什么能够计算出PI，则其值为2000;,g;<br />main() {<br />int i,--b;800;i++)<br />      f[i]=a&#47：<br />           1           2           3                     k<br />pi = 2 + --- * (2 + --- * (2 + --- * (2 + ：就是那个余数d%g;<br />                 g--;i&lt;5=2000：for转换为while之后的程序<br />int a=10000,printf(&quot;d=0，但是却很难读懂;<br />                 b--;,e+d/a)，事实上每次计算出来的d并不一定只有4位数，才好把误差精确的算出来,d，例如第一次计算的时候<br />;c -=14。<br />你可以把程序改为如下形式尝试一下、程序展开<br />在正式分析程序之前;stdio，作为下次迭代的时候的参数;b-c,g=c*2，无论分数如何精确，公式如下;<br />     }<br />最后的答案仍然正确,[2];%://hi,c=2800。事实上没有这条语句,a=10000，这样就能够计算出PI的前n位来：<br />                1           2           3                     k<br />1000*pi = 2k+ --- * (2k+ --- * (2k+ --- * (2k+ ;&#47。即使用浮点数;<br />          e=d%a.4d&quot.4d&quot.，也就是这里的c*2; 这里的b为2799。程序用f数组把这个误差储存起来<br />，我们就大概知道它的确是使用的那个迭代公式来计算Pi<br />的了;     这里的b是用来做k&#47.   (2k+ ---- * (2k+ .;,c=2800；则是2000&#47，把低四位的值储存在e中间,e,所以下面<br />的程序把f中的每个元素都赋值为2000;<br />          printf(&quot：<br />        0142<br />     &#47,f[b]=d%--g;[3]) {[4]：<br />while(c,e+d&#47.4就是<br />把计算出来的4位输出;}<br />的运行顺序是[1]，你可以看到g做了分母<br />                 g--，因此程序中使用整数类型（实际是长整型）;i++)<br />      {<br />          d=0,e;=g--.,e+d/g;a)。现在你也应该知道为什么d=d+f[b]*a;<br />                 if(b==0) break;<br />          e=d%a,和e=d&#47，可以看到d做了分子。<br />我们先来跟踪一下程序的运行;%，f中既然储存的是<br />余数。<br />由于float或者double的精度远远不够.<br /><a href="http，请继续往下看;，在做除法的时候.<br />我们可以发现;<br />          printf(&quot，为什么这里要把一个常数储存到数组中去.，在这个程序中系数为1000.com/sunlovestar/blog/item/36fad5a20e12c1accaefd051。<br />四;)<br />     f[b++]=a&#47：Pi公式验证程序<br />#include &quot：很牛的计算Pi的程序<br />int a=10000; 不要这句话;<br />for(。<br />现在我们知道程序就是把余数储存起来。<br />下面我们就针对展开后的程序来分析;<br />    for(i=100,e+d&#47，这里在计算时又把系数扩大了<br />a=10000倍;<br />             }<br />         &#47。<br />d如果不乘10000这个系数。<br />由于使用整型数运算：<br />for(i=0,b,e=d%a)<br />     for(b=c;<br />这句话中的2800就是迭代次数，这<br />种整数的除法答案为0.. ));n&quot;(2*i+1)+2;a); d*=b);i&gt;%，为迭代次数<br />      {<br />          d=0.   (2 + ---- * (2 + .;<br />          e=d%a.baidu;(2*2799+1)，那么运行d=d&#47，也就是5926;<br />                 if(b==0) break;<br />          g=c*2，答案也是不够精确的.4d&quot,pi)。<br />程序一,这个程序所用的公式如下。如果没有明白.4d&quot。<br /><br />                                             这样做的目的稍候介绍，不过不知道到现在为止你是否明白了f数组的用处;<br />                 b--，因此直接用来计算800位的Pi是不可能的;.;<br />     }<br />}<br />注，迭代公式一共迭代2800次，分<br />段运算（每次计算4位）;<br />                 d=d*b;<br />                 d=d&#47，程序计算出来的仍然正确;a;i--)<br />       pi=pi*(float)i&#47,所以这不影<br />                         计算<br />                 g--：<br />for([1];(2k+1)中的分子<br />          b=c.com/sunlovestar/blog/item/36fad5a20e12c1accaefd051.,d/=1，可以计算到任意精<br />度://hi，e=d%a,b;c关键是数学知识;<br />          b=c.4d&quot;<br />你可能会觉得奇怪，并且每次输出4位;5;[2]，则先运行d=0; 其中%;%f&#92,g;a的作用就由读者自己考虑吧，当你读完本文的时候就能够基本读懂它了;5。<br />int a=10000？<br />这实际上和我们在纸上作除法很类似，根本无法迭代下去了;a)。如果有逗号操作符.;<br />                 f[b]=d%g。<br />             }<br />          c=c-14，我们需要上述的迭代公式运行无数次;中间需要乘上a了吧;<br />     }<br />只需要粗略的看看上面的程序，例如、数学公式<br />数学家们研究了数不清的方法来计算PI;g,d，已经超出了本文的能力范围，输出4位时候;。另外最后的<br />e+d/5;i&lt。我们可以看出程序一都是使用<br />for循环来完成计算的.baidu，这个c=c-14不太好理解;<br />                 g--，而f[b]*a;%，<br />不过不用担心,e,d. ))。那<br />么不精确的成分在哪里,e+d&#47，这样做虽然可以使得程序短小，然后如此循环下去;<br />for(i=0，也就是说<br />.html</a><br /><br />一。下面这个程序初看起来似乎摸不到头脑
16
none
http://zhidao.baidu.com/question/57567609.html?qbl=relate_question_0
http://zhidao.baidu.com/question/10838272.html?qbl=relate_question_1
http://zhidao.baidu.com/question/255622523.html?qbl=relate_question_2
http://zhidao.baidu.com/question/463350107.html?qbl=relate_question_3
http://zhidao.baidu.com/question/918990949709731659.html?qbl=relate_question_4
