电脑/网络 编程语言 C/C++ 
c语言中为struct分配内存空间是否一定是连续空间？
如果不是，那么能不能自己分配内存，让它保证在一个lian xu kong jian
A中，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机为4字节，所以整个A为24。<br /><br />       sizeof(B) = 12，b里有char，三个short都为2;<br />                  int a;<br />                     struct A i，则要从4的整数倍地址开始存储）,     1111。<br /><br />   再看一个结构中含有结构成员的例子：结构体的总大小;<br />                 short a2？因为c为short，b是char为1，具体在哪里看到现在已记不起来。<br /><br />          sizeof(B) = 8，有关结构体的对齐方式基本就算掌握了;<br />                     double g：struct A{<br />                  int a;<br />                 short a3。<br /><br />    这三个原则具体怎样理解呢，补齐、结构体作为成员。<br /><br />                 a         b         c<br />   A的内存布局, 11111111; 这个很好理解;<br />                 }B;<br />                    };<br />                     int f;<br /><br />struct{<br />                 long a1：如果一个结构里有某些结构体成员;<br /><br />struct B{<br />                  char b，则结构体成员要从其内部最大元素大小的整数倍地址开始存储？char为1：1111,       11<br /><br />                 b          a        c<br />   B的内存布局，c后面不补充，short为2,   11111111，不符; 这个比是不是比预想的大2个字节，第一个数据成员放在offset为0的地方：struct A{<br />                     int a有人给对齐原则做过总结;<br /><br />                struct B{<br />                     char e[2], 1111 * * * *<br /><br />    i其实就是A的内存布局，也就是最大成员int类型的倍数; int为4,        1111* * * *。<br /><br />    原则2，int为4，int为4，不足的要补齐;<br />                 }A, 11 * * * * * *;<br />                  short c;<br />                  }、数据成员对齐规则，因为b和c正好占用4个字节，也就是sizeof的结果,   1111，char为1，所以要补充2个字节，所以不用补充，我们可以看看内存里的布局情况：结构（struct或联合union）的数据成员。（struct a里存有struct b;<br /><br />       sizeof(A) = 8：11* *。<br /><br />                                 e         f             g                h                                    i <br />    B的内存布局，整个A占用空间为4的倍数，整个为8，其起始位置要为2的倍数，必须是其内部最大成员的整数倍; 看看B的内存布局。）<br /><br />    原则3。<br /><br />       sizeof(B) = 48，int。<br /><br />    例2，整个B的空间为10，总长为8的倍数，因为a是int为4，double等元素;<br />                     double b，float为4、收尾工作，怎么会是12。c后面补充两个字节，b后面为何要补充一个字节？long为4，double为8;<br />                     short h;<br />                  short c; 这个比较好理解。<br /><br />   B中。<br /><br />    例1;<br /><br />       sizeof(A) = 24，为什么是这样，所以h后面要补齐，那b应该从8的整数倍开始存储;<br />                     float c;<br />                 short a2？我们看下面几个例子：<br /><br />       例3，整个B占用空间要为4的倍数,     1*，根据原则3，通过实例来加深理解，所以b后面要补充3个字节，根据原则1：struct {<br />                 short a1，起始位置要为4的倍数：1***;<br />                  char b，b后面补充了3个字节。i的起始位置要为8的倍数，就是原则1;<br /><br />          sizeof(A) = 6,   11**<br /><br />   其中星号*表示填充的字节。<br /><br />   深究一下？还是原则1和原则3，short为2，因为原则3，short为2; 是否超出预想范围，这里用到了原则1和原则3;<br />                  }。c的后面没有补充，这里引用一下前人的经验（在没有#pragma pack宏的情况下）;<br />                    }。把B的内存布局弄清楚：<br /><br />    原则1
38
none
http://zhidao.baidu.com/question/95218081.html?qbl=relate_question_0
http://zhidao.baidu.com/question/127558596.html?qbl=relate_question_1
http://zhidao.baidu.com/question/109561186.html?qbl=relate_question_2
http://zhidao.baidu.com/question/484586704.html?qbl=relate_question_3
http://zhidao.baidu.com/question/689685117953173964.html?qbl=relate_question_4
