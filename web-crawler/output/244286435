电脑/网络 编程语言 C/C++ 
C语言中void的作用是什么？
none
。但是我们在真实设计时：<br />  （1） 对函数返回的限定，也可以发挥代码的“自注释”作用;<br />fun()<br />{<br />return 1: cannot convert from &#39;#include  &lt，我们在编写C&#47：正确;示例，还是应该尽可能地迎合<br /><br />ANSI标准，在C语言中，就应该把它置为NULL（0）;ANSI.h&gt，它也没有任何实际意义，我们可以说“男人和女人都是人”，而“有类型”则不能包<br /><br />容“无类型”;”;&lt；GNU。<br /><br />3。正如不能给抽<br /><br />象基类定义一个实例，所以不能寄希望于编译器会做严格的类型检查;/<br /><br />  但这并不意味着.0上测试是sizeof(int)的倍数)<br /><br />  在实际的程序设计中;&#47, 3) )，GNU较ANSI更“开放”;<br />}<br />&#47。另外：memcpy接受任意类型指针<br />int intarray1[100];int *&#39：正确<br /><br />  GNU和ANSI还有一些区别; , 100*sizeof(int) )，这说明;”。<br />对于好的编程习惯来说; (int)*p2 &lt。本文将对void关键字的深刻含义进行解说, int b )<br />{<br />return a + b;ANSI，则必须使用强制类型<br /><br />转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。<br /><br />  void的出现只是为了一种抽象的需要, size_t len)！这样的memcpy和memset明显不是一个<br /><br />“纯粹的;&lt;stdio，void *则为“无类型指针”：<br />0xCCCCCCCC<br />0x0012FF78<br />0x0012FF78<br />0x0012FF78<br />  *&#47，必须改为：<br />void * pvoid。<br /><br />  因此，对于任何函数都必须一个不漏地指定其类型。<br /><br />  规则四如果函数的参数可以是任意类型指针;<br />}<br />int main(int argc;int *&#39。<br /><br /> 因此下列语句在GNU编译器中皆正确;=&#39;;&#47：正确<br />pvoid += 1, char*。( 在VC6;&#47。如果函数没有返回值。<br /><br />  所以，在release状态下不会等于这个值（除非巧合）;<br />而void *则不同, float*oid及void指针类型不甚理解.h&quot;void *&#39; (int)*p2 &lt：<br />void * pvoid.h&gt，无需进行强制类型转换。在C++<br /><br />中，为迎合ANSI标准; /&#47!。<br /><br />  我们将在第三节对以上二点进行具体说明，也是编程规范性的要求，总体而言，则初始化为NULL; &#47.void的使用<br /><br />  下面给出void关键字的使用规则，即使void a的编译不会出错：<br />void *p1：错误<br />&#47。对于指针如果暂时没有合适的初始化值;&lt。<br /><br />  void几乎只有“注释”和限制程序的作用;<br />(char *)pvoid++; &#47：<br />void a;&#47。如果memcpy和memset的参数类型不是void *：<br />int function(void)<br />{<br />return 1;&#47，譬如在Visual C++6，这也真实地体现了内存操作函数的意义，那么应声明其参数为void *<br /><br />  典型的如内存操作函数memcpy和memset的函数原型分别为，凡不加返回值类型限定的函数;&#47：正确<br />(char *)pvoid += 1,fun(2)); endl，可以给无参数的函数传送任意类型的参数, 100*sizeof(int) );<br />cout &lt，如果是类成员 则在构造函数中initialize，提示“&#39：“C++语言有很严格的类型安全检查;例如;下面自己整理了点<br /><br />不论什么类型的指针(void*：<br />  2 + 3 = 5<br />  这说明不加返回值说明的函数的确为int函数;&#47。 <br /><br />-------------------------------------------/<br /><br />在声明同时赋值NULL;ANSI。这既是程序良好可读性的需要; &#47，加上void类型声明后，并提高程序的可移植性;<br />}<br />main()<br />{<br />printf(&quot，也很容易理解void数据类型;<br />void main()<br />{<br />void *p1，脱离低级趣味的”函数;<br /><br />  提示“&#39：<br />void * memcpy(void *dest;<br />int *p2 = &a：<br /><br />void a：<br />add ( int a：<br />int *pint;<br />/;<br />p1 = p2。道理很简单;<br />void * memset ( void * buffer;&#47.总结<br />  小小的void蕴藏着很丰富的设计哲学, intarray2，就会被编译器作为返回整型值处理;/s Not Unix的缩写)则不这么认定;fun&#39;<br />p2 = p1，并<br /><br />详述void及void指针类型的使用方法与技巧！<br />cout &lt，用来提示这个指针是未被初始化的.0中编译.<br /><br />0xCCCCCCCC只是在debug状态下VC生成的未定义过的指针值。<br /><br />  例如，标准库函数的编写者是多么地富有学问啊;.) 默认初始值都是0xCCCCCCCC<br /><br />#include&lt.0上测试是sizeof(int)的倍数)<br /><br />  但是大名鼎鼎的GNU(GNU&#39；<br />  （2） 对函数参数的限定！<br /><br />下面的代码执行正确.0中上述add函数的编译无错也无警告且运行正确;<br /><br />  其中p1 = p2语句会编译出错;2 + 3 = %d&quot，如果你正确地理解了面向对象中“抽象基类”的概念.：进行算法操作的指针必须是确定知道其指向数据类型大小的;&lt;float *&#39，出错提示“&#39，因此都是错误的代码。代码的“自注<br /><br />释”即代码能自己注释自己。例如;将intarray清0<br /><br />/ / /C++程序时。<br /><br />  众所周知，那么我们可以直接在p1和p2间互相赋值。<br />/<br />}<br /><br />  编译正确且输出1!;%d&quot，对问题进行深一个层次的思考必然使我们受益匪浅，即下列操作都是不合法的;<br />pvoid++，（在我电脑上VC6，不允许上述情况（指函数不加类型声明）发生”：正确<br /><br />  pvoid++的执行结果是其增大了1; *(int*)p1 &lt，因为它操作的对象仅仅是一片内存; endl!!  用空类型操作输出值;<br />p1 = p2;/ to &#39; &#47，则置它为NULL;* 输出;<br /><br />  这样。<br /><br />  林锐博士《高质量C/<br />int *p2;将intarray2拷贝给intarray1<br /><br />  有趣的是，如果指针p1和p2的类型相同, 0; &#47，那才叫真的奇怪了！<br /><br />  规则五 void不能代表一个真实的变量<br /><br />  下面代码都企图让void代表一个真实的变量;<br /><br />  因为在C++中.h&gt;ANSI。<br /><br />在debug版本下指针默认初始值为0xCCCCCCCC; , add ( 2，当对指针使用delete时候，让我们试着来定义;<br />int a = 10;<br />cout &lt，提供了对更多语法的支持，它指定void *的算法操作与char *一致，任何类型的指针都可以直接赋值给它.void的含义<br />  void的字面意思是“无类型”, intarray2[100];//”!，是因为它坚持，我们可以这样编写实现同样功能的代码; p1 &lt;<br />int *p2;void&#39;/C++编程》中提到，void *也可以无需强制类型转换地赋给其它类型的指针。<br /><br />  void真正发挥的作用在于;&lt;<br />memcpy ( intarray1，函数参数为void的意思是这个函数不接受任何参数;memory;<br />getchar()!;错误<br /><br />  void体现了一种抽象。<br /><br />2，declare一个指针，就应该把它置为NULL（0），无论在C还是C++中；GNU：<br />p1 = (float *)p2;GNU：错误<br />pvoid += 1：错误，memcpy和memset函数返回的也是void *类型;错误<br />function(void a)。( 在VC6，一定要声明为void类<br /><br />型。不过。因为“无类型”可以包容“有类型”;<br />p1 = p2, int*：正确<br /><br />  pint++的结果是使其增大sizeof(int)。<br /><br />4;<br />pint++，这个世界上的变量都是“有类型”的;示例;iostream，任何类型的指针都可以传入memcpy和memset中，因此在使用上出现了一些错误; to &#39，在delete后立即设置为NULL: function does not take 1 parameters”。但是许多程序员却误以为其为void类型,那么应声明其参数为void<br /><br />  在C++语言中声明一个这样的函数.; ;<br />int *p2，而不<br /><br />论这片内存是什么类型：<br />float *p1。下面的语句编译出错;<br />cout &lt;<br />#include &lt;&lt, int c.0）; &#47，一定要指明参数为void;&#47, char* argv[])<br />{<br />printf ( &quot：<br />#include &quot;<br />memset ( intarray;&lt;/&lt：<br />void *p1。<br /><br />  规则三 小心使用void指针类型<br /><br />  按照ANSI(American National Standards Institute)标准;ANSI标准之所以这样认定：<br />  规则一 如果函数没有返回值，不能向无参数的函数传送任何参数：<br />&#47：<br />function(2); endl，若函数不接受任何参数，那么应声明为void类型<br /><br />  在C语言中;<br />}<br /><br />  程序运行的结果为输出，我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量;&#47。<br /><br />  我们在Turbo C 2，为了避免混乱。可是编译<br /><br />器并不一定这么认定，而是char *。<br /><br />    规则二如果函数无参数。对于指针如果暂时没有合适的初始化值：<br />pvoid++; &#47，作为一名程序设计人员？）; endl;<br />}<br /><br />  则进行下面的调用是不合法的，但是在C++编译器中编译同样的代码则会出错：memset接受任意类型指针<br />int intarray[100]，不能对void指针进行算法操作;GNU, size_t num );/ANSI，因为从来没有人会定义一个void变量, const void *src;string，譬如一个人不是男人就是女人（还有人妖，在Release版本下初始值为0x0000000A;=&#39;<br /><br />  这行语句编译时会出错；如果p1和p2指向不同的数据类型，但不能说“人是男人”或者“人是女人”，void *可以指向任何类型的数据; &#47: cannot convert from &#39，提示“illegal use of type &#39
16
none
http://zhidao.baidu.com/question/39566973.html?qbl=relate_question_0
http://zhidao.baidu.com/question/687570463191538364.html?qbl=relate_question_1
http://zhidao.baidu.com/question/115707062.html?qbl=relate_question_2
http://zhidao.baidu.com/question/1731982224027086787.html?qbl=relate_question_3
http://zhidao.baidu.com/question/85603308.html?qbl=relate_question_4
