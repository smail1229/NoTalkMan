电脑/网络 编程语言 C/C++ 
用C语言编51单片机的简单计算器软件？
51单片机上实现一个简单运算（+;等功能）的计算器，*！急需，&#47！谢谢，―！大家帮帮忙哈~，使用C语言来编制程序
0xf7};<br />  operator=0;&#47,0;&#47、 显示区<br />unsigned char key_buffer[2]={0;键码<br />     {     case 0x77,0x07;        /i++) <br />                                     disp_buffer[i]=disp_buffer[i+1];<br />               break;=4;扫描<br />  switch(P1)     &#47,0xfb;<br /> }<br />void get_keypad_code() interrupt 2<br />{     unsigned char i;<br />                          tempb=1000*temp[1]+100*temp[2]<br />                                     +10*temp[3]+temp[4];=3;          &#47:<br />      case 1！（89C51） 别忘了保存文件名后的 ;       /<br />     EX1=1;<br />unsigned char light[4]={0xfe;/<br />     IT1=0:return(0x0);<br />                      disp_buffer[4]=tempa%10; <br />                                          }<br />                          first=0;1000;<br />  for (j=0;<br />       case 0x7e;/<br />     PT0=1;=k:tempa=tempb-tempa:return(0xb)、键码<br />void main(  )<br />{<br />      unsigned char temp[5];读键码<br />            if (key;<br />     ET0=1,0;<br />    switch(operator)<br />     {      case 10; <br />      unsigned char operator=0;/                /<br />  break:<br />      case 7;<br />      unsigned int tempa;延时2;缓冲区空<br />            }           <br />       } <br /> } <br />void disp_LED() interrupt 1<br />{     TL0=0x0;  <br />     EA=1;<br />                     first=1;<br />                                   case 13;/<br />       case 0xed: for(i=1;                              <br />                          tempa=1000*disp_buffer[1] +100*disp_buffer[2]<br />                                  +10*disp_buffer[3]+disp_buffer[4];&#47:<br />       case 12:return(0xc);延时k*1ms<br />{ unsigned int i.h&quot;<br />     TMOD=0x01;              /i++)  disp_buffer[i]=temp[i]=0！我刚试了下<br /><br />#define LED_seg      XBYTE[0x6000]     /&#47:<br />      case 8;<br />       for (i=0,0x5e;段码<br />unsigned char disp_buffer[5]={1;<br />       default:<br />       case 11;<br />#include &quot;<br />  if ((disp_key&gt;<br />     PX1=1;缓冲区满<br /> {   case 0;        &#47:<br />      case 5:return(0xd):return(0x4);<br />       EA=0;100:return(0x7);10,0x39;disp_key 显示字符;/<br />       case 0xdb;<br />                     tempa%=1000:tempa*=tempb;=1085:<br />      case 6;/<br />  else  LED_seg=0x00:return(0x1);<br />       case 0xee:tempa+=tempb;=16)) <br />                   LED_seg=seg[disp_key]!=key) key=0xff;<br />unsigned char display(unsigned char; <br />    break;&#47我来给你发个,0x6d;j&lt;开中断<br />while(1)<br />{      P1=0xf0:<br />         case 3;/<br />     TR0=1,key;<br />                                   case 12,0xfd;/<br />                      disp_buffer[1]=tempa/<br />       case 0xbb;<br />       case 0xeb;<br />       case 0x7d;   /<br />       case 0xde;<br />                    case 11;/&#47,0x7c;absacc;扫描<br />       if (key_buffer[0])<br />       { switch(key_buffer[1])  /                           /i++)<br />                         {    temp[i]=disp_buffer[i];<br />       case 0xbe,0x71};读键码比较<br />            if (key;<br />       case 0xe7;=1))   LED_light=light[n-1];<br />                      tempa%=100,j;<br />       case 0xd7;<br />       case 10;<br />        for(i=1;     /       &#47:<br />      case 9:return(0x2);=4;延时2;&#47:<br />       case 14;<br />                                     break;<br />       case 0xb7,0x7d;// <br />      bit first=1;键码<br />             }                      <br />       }<br />      EA=1;/&#47,去抖动<br />            if (read_key(light[i]); <br />        break;当前灯位,0};<br />                case 15;<br />      unsigned char i;/        /<br />void delay(unsigned int);       /i&lt,tempb:<br />      case 4;<br />  operator=key_buffer[1];   /       /&#47,unsigned char n) /<br /> }<br /><br />void delay(unsigned int k)     &#47,0x77;<br />  return light[n-1];<br />       case 0x7b.5mS的定时器初始值<br />     TH0=0xf7;缓冲区满标志;/<br />      if (disp_buffer[0]==5)  disp_buffer[0]=1,0,0x4f;i++)      !=0xff) delay(50),0x66;<br />  else  LED_light=0xff;&#47,unsigned char);                  /返回扫描码-&gt;=3:return(0xf);=4)&&(n&gt:return(0xe);i&lt!=0xff)<br />  {      key_buffer[0]=1;<br /> } <br />unsigned char read_key(unsigned char scan)<br />{     P1=scan;灯位地址<br />#include &quot:return(0xa);&#47,<br />0x7f:tempa=tempb&#47,n 灯位<br />{  if ((n&lt:return(0x5):<br />       case 13;<br />                      disp_buffer[3]=tempa/<br />                           } <br />           tempa%=10000: first=1;i&lt;<br />      }<br /> } <br />unsigned char display(unsigned char disp_key;<br />     }<br />                key_buffer[0]=0:return(0x8): if (first)  for(i=1.5mS的定时器初始值<br />      TH0=0xf7;<br />                      disp_buffer[2]=tempa/reg51,0xff},0x79:  return(0xff),0x5b;tempa;缓冲区满<br />        key_buffer[1]=key:return(0x9);i&lt.h&quot;<br />      disp_buffer[0]++;<br />       case 0xdd;i++)<br />      {    key=read_key(light[i]);i&lt;<br />       case 0xbd:return(0x6);<br />        disp_buffer[4]=key_buffer[1];段码地址<br />#define LED_light    XBYTE[0x8000]      /扫描值 灯位码<br />unsigned char seg[16]={0x3f;         &#47:<br />      case 2;置T0为方式1<br />     TL0=0x0;   /<br />unsigned char read_key(unsigned char),0x6f;    &#47.c <br />绝对可运行;<br />                     disp_buffer[i]=0;延时5-10ms,0x06;=0)&&(disp_key&lt;  /j++)<br />      for(i=0:return(0x3),disp_buffer[0]);<br />      display(disp_buffer[disp_buffer[0]]
3
none
http://zhidao.baidu.com/question/531795497.html?qbl=relate_question_0
http://zhidao.baidu.com/question/350927585.html?qbl=relate_question_1
http://zhidao.baidu.com/question/217260745.html?qbl=relate_question_2
http://zhidao.baidu.com/question/409922231.html?qbl=relate_question_3
http://zhidao.baidu.com/question/2074162288470643188.html?qbl=relate_question_4
