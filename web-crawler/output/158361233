电脑/网络 编程语言 C/C++ 
C语言程序注释
j++)<br />    {<br />      if(queue[j]==-1)<br />          continue,int len)<br />{<br />  int i=0,90,j=0;<br />    i=0;<br />   int queue[9]={55;<br />void sstf(int current,sum=0;<br /> }<br />  printf(&quot;average=%f&#92;len)，可以不用十分详细（这个是操作系统里面的最短寻道优先算法）<br />#include &quot;n&quot.h&quot,queue;len,58,150希望大神给出下面程序的注释;;<br />         }<br /><br />    }<br /><br />  printf(&quot;<br /> }<br /><br />main()<br /> {<br />   int current=100,160,39;math;<br />  current=queue[i];<br />  while(1)<br />  { if(count ==len )<br />       break;<br />#include &quot,queue[i]);n&quot;stdio;<br />  sum=sum+abs(current-queue[i]),min=0;<br />  printf(&quot;min)    <br />        {min =abs(current-queue[j]);%d&#92;<br />    while(queue[i]==-1)<br />     {i++,sum*1;<br />      if(abs(current-queue[j])&lt;,9);}<br />    min = abs(current-queue[i]),sum);sum=%d&#92;<br />   <br />    for(j=i+1;<br />   sstf(current;<br />         i=j,18;n&quot;j&lt;<br />  queue[i]= -1,int *queue,184};.0&#47,count=0.h&quot,38;<br />  count++
若为-1就跳过,int len)<br />{<br />  int i=0;//这一步的长度加到总长度中<br />   current=queue[i];&#47,min用来记录步最小路径<br />  while(1){ <br /> if(count ==len )break;sum表示总路径长度;/n&quot，下一次比较重跳过<br />   count++;/当前位置到数组中i位置的路径的绝对长度<br />   <br />     for(j=i+1;改写当前位置<br />   queue[i]= -1; /&#47，是为了做到不重复<br /><br />     min = abs(current-queue[i])，在下边有,queue[i]);  &#47,queue;<br />           i=j;/n&quot,38;/j++){  //磁盘位置<br />   sstf(current.0//   /;i记录数组位置;len;} /min){ /<br />void sstf(int current，不用说吧<br />#include &quot;stdio,58;把当前值赋为-1;<br />  }/ /for end  <br /><br />   printf(&quot,160;&#47,sum);<br />     while(queue[i]==-1){i++;&#47,j=0;sum=%d&#92，若为-1就跳过;/ &#47,39,count=0;if end<br />    } /j&lt;<br />     i=0;   /  /屏显第i个位置<br />   sum=sum+abs(current-queue[i]).h&quot;/;设定初始的当前位置<br />   int queue[9]={55;,184},90;<br />          }/while end<br />  printf(&quot; &#47,int *queue;&#47,min=0,150; /&#47，j用在下边的比较中,sum*1; &#47，在下边有;屏显最短路径总长<br />  printf(&quot.h&quot;&#47,18;/屏显平均长度<br /> }<br /><br />main()<br /> {<br />   int current=100;/用穷举比较的方法找到最短路径<br />   min =abs(current-queue[j]),用queue[j]和当前位置current计算路径长度<br />     /len);库包含;这个不用看了;n&quot;/average=%f&#92;%d&#92;math，是为了做到不重复<br />        if(abs(current-queue[j])&lt; /&#47,sum=0#include &quot; /从i的下一个位置开始找出这一步的最短路径<br />        if(queue[j]==-1)continue,9)
1
none
http://zhidao.baidu.com/question/154740115.html?qbl=relate_question_0
http://zhidao.baidu.com/question/448463065.html?qbl=relate_question_1
http://zhidao.baidu.com/question/87308368.html?qbl=relate_question_2
http://zhidao.baidu.com/question/560316171.html?qbl=relate_question_3
http://zhidao.baidu.com/question/103726270.html?qbl=relate_question_4
